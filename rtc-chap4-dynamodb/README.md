# Chapter 3: Unit Tests

Continuing from implementing persistence in Chapter 2, we'll be tackling a task that we've been deferring for a while now - unit tests. Admittedly, this is something that many developers defer to later stages as well. However, doing so just leads to a huge debt. Do it late enough and you'll end up with the daunting task of writing unit test for an entirely functional service which will undoubtedly be demotivating.

It's also understandable to think that doing it too early seems unnecessary though I would definitely advocate for that. At the very least, though, my take is to forgive ourselves in deferring it for a while at most _until_ we get to a state where we've got the big pieces in place. For example, in this project, we have our database connection set up, a controller, and the initial liquibase changelogs to setup a table. In the past 2 chapters, we've been essentially "setting up" the foundations of what would become a service. We haven't really implemented anything complex yet but the pieces to support it are there for a running service. Likewise, we should also start setting up the foundations of our unit testing "environment". That's an oxymoron, of course, since the idea of unit testing is to test a very small and isolated piece of work without external influences. That said, what we're setting up here is the harnesses around the tests that we will eventually need - specifically once we start testing the Spring Boot app itself.

We'll be writing proper unit tests for the controller that we have so far since that's the only testable code we have. Additionally, we'll be writing integration tests for the app itself with an in-memory database to tests the request routing, and field validations.
